/*
 * Copyright (C) 2008 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package android.alarmManager.test;


import android.app.AlarmManager;
import android.app.PendingIntent;
import android.content.Context;
import android.content.Intent;
import android.content.IntentFilter;
import android.os.SystemClock;
import android.os.Build;
import android.test.AndroidTestCase;
import java.io.IOException;
import java.util.TimeZone;
import android.util.Slog;

public class AlarmManagerTest extends AndroidTestCase {
    private AlarmManager mAlarmManager;
    private Intent mIntent;
    private PendingIntent mSender;
    private Intent mServiceIntent;
    private static final String TAG = "AlarmManagerServiceaAutoTest";
    private String CHANGE_TIME_ZONE;
    private String CURRENT_TIME_ZONE;
    private String BASE_TIME_ZONE;
    private TimeZone tz;
    private int rawoffset = 0;
    private String mBuildVersion;
    private  int  mBuildSDK;
    private static final String mTestTargertOne = "Asia/Seoul";    //GMT+09:00
    private static final String mTestTargertTwo = "America/Bogota"; //GMT-05:00
    /*now just for n_eac test
     *to do: modify the name for official release
     */
    private static final String mAndroid_N = "N";
    /*
     *  The default snooze delay: 5 seconds
     */
    private final long SNOOZE_DELAY = 5 * 1000L;
    private long mWakeupTime;
    private MockAlarmReceiver mMockAlarmReceiver;

    private final int TIME_DELTA = 200;
    private final int TIME_DELAY = 4000;
    private final int ONE_MINITE = 60 * 1000;
    private final int TEN_MINITE = 10 * ONE_MINITE;

    class Sync {
        public boolean mIsConnected;
        public boolean mIsDisConnected;
    }

    @Override
    protected void setUp() throws Exception {
        super.setUp();
        mAlarmManager = (AlarmManager) mContext.getSystemService(Context.ALARM_SERVICE);
        mBuildSDK = android.os.Build.VERSION.SDK_INT;
        mBuildVersion = android.os.Build.VERSION.RELEASE;
        mIntent = new Intent(MockAlarmReceiver.MOCKACTION);
        mSender = PendingIntent.getBroadcast(mContext, 0, mIntent, 0);
        mMockAlarmReceiver = new MockAlarmReceiver();
        IntentFilter filter = new IntentFilter(MockAlarmReceiver.MOCKACTION);
        mContext.registerReceiver(mMockAlarmReceiver, filter);
    }

    @Override
    protected void tearDown() throws Exception {
        super.tearDown();
        if (mServiceIntent != null) {
            mContext.stopService(mServiceIntent);
        }
    }

    public void testSetTypes() throws Exception {
        // TODO: try to find a way to make device sleep then test whether
        // AlarmManager perform the expected way
        // test parameter type is RTC_WAKEUP
        mMockAlarmReceiver.setAlarmedFalse();
        mWakeupTime = System.currentTimeMillis() + SNOOZE_DELAY;
        mAlarmManager.set(AlarmManager.RTC_WAKEUP, mWakeupTime, mSender);
        // test parameter type is PowerOffAlarm

        //mAlarmManager.set(7, mWakeupTime, mSender);
        //mAlarmManager.cancelPoweroffAlarm("com.android.deskclock");

        // test parameter type is RTC
        Thread.sleep(SNOOZE_DELAY + TIME_DELAY);
        assertTrue(mMockAlarmReceiver.alarmed);
        assertEquals(mMockAlarmReceiver.rtcTime, mWakeupTime, TIME_DELTA);

        mMockAlarmReceiver.setAlarmedFalse();
        mWakeupTime = System.currentTimeMillis() + SNOOZE_DELAY;
        mAlarmManager.set(AlarmManager.RTC, mWakeupTime, mSender);
        Thread.sleep(SNOOZE_DELAY + TIME_DELAY);
        assertTrue(mMockAlarmReceiver.alarmed);
        assertEquals(mMockAlarmReceiver.rtcTime, mWakeupTime, TIME_DELTA);

        // test parameter type is ELAPSED_REALTIME
        mMockAlarmReceiver.setAlarmedFalse();
        mWakeupTime = SystemClock.elapsedRealtime() + SNOOZE_DELAY;
        mAlarmManager.set(AlarmManager.ELAPSED_REALTIME, mWakeupTime, mSender);
        Thread.sleep(SNOOZE_DELAY + TIME_DELAY);
        assertTrue(mMockAlarmReceiver.alarmed);
        assertEquals(mMockAlarmReceiver.elapsedTime, mWakeupTime, TIME_DELTA);

        // test parameter type is ELAPSED_REALTIME_WAKEUP
        mMockAlarmReceiver.setAlarmedFalse();
        mWakeupTime = SystemClock.elapsedRealtime() + SNOOZE_DELAY;
        mAlarmManager.set(AlarmManager.ELAPSED_REALTIME_WAKEUP, mWakeupTime, mSender);
        Thread.sleep(SNOOZE_DELAY + TIME_DELAY);
        assertTrue(mMockAlarmReceiver.alarmed);
        assertEquals(mMockAlarmReceiver.elapsedTime, mWakeupTime, TIME_DELTA);
    }

    public void testAlarmTriggersImmediatelyIfSetTimeIsNegative() throws Exception {
        // An alarm with a negative wakeup time should be triggered immediately.
        // This exercises a workaround for a limitation of the /dev/alarm driver
        // that would instead cause such alarms to never be triggered.
        mMockAlarmReceiver.setAlarmedFalse();
        mWakeupTime = SystemClock.elapsedRealtime()  - ONE_MINITE;
        //Slog.d(TAG, "SystemClock.elapsedRealtime() = " + SystemClock.elapsedRealtime() );
        //Slog.d(TAG, "mWakeupTime = " + mWakeupTime );
        mAlarmManager.set(AlarmManager.ELAPSED_REALTIME_WAKEUP, mWakeupTime, mSender);
        Thread.sleep(10000);
        assertTrue(mMockAlarmReceiver.alarmed);
    }

    public void testSetRepeating() throws Exception {
        mMockAlarmReceiver.setAlarmedFalse();
        mWakeupTime = System.currentTimeMillis() + SNOOZE_DELAY;
        mAlarmManager.setRepeating(AlarmManager.RTC_WAKEUP, mWakeupTime, ONE_MINITE, mSender);
        Thread.sleep(SNOOZE_DELAY + TIME_DELAY);
        assertTrue(mMockAlarmReceiver.alarmed);
        mMockAlarmReceiver.setAlarmedFalse();
        Thread.sleep(70 * 1000);
        assertTrue(mMockAlarmReceiver.alarmed);
        mAlarmManager.cancel(mSender);
    }

    public void testCancel() throws Exception {
        mMockAlarmReceiver.setAlarmedFalse();
        mWakeupTime = System.currentTimeMillis() + SNOOZE_DELAY;
        mAlarmManager.setRepeating(AlarmManager.RTC_WAKEUP, mWakeupTime, ONE_MINITE, mSender);
        Thread.sleep(SNOOZE_DELAY + TIME_DELAY);
        assertTrue(mMockAlarmReceiver.alarmed);
        //mMockAlarmReceiver.setAlarmedFalse();
        //Thread.sleep(TIME_DELAY);
        //assertTrue(mMockAlarmReceiver.alarmed);
        mAlarmManager.cancel(mSender);
        //Thread.sleep(TIME_DELAY);
        mMockAlarmReceiver.setAlarmedFalse();
        Thread.sleep(ONE_MINITE + TIME_DELAY);
        assertFalse(mMockAlarmReceiver.alarmed);

    }

    public void testSetInexactRepeating() throws Exception {
        mMockAlarmReceiver.setAlarmedFalse();
        mWakeupTime = System.currentTimeMillis() + SNOOZE_DELAY;
        mAlarmManager.setInexactRepeating(AlarmManager.RTC_WAKEUP,
                      mWakeupTime, ONE_MINITE, mSender);
        Thread.sleep(SNOOZE_DELAY + TIME_DELAY);
        assertTrue(mMockAlarmReceiver.alarmed);
        mMockAlarmReceiver.setAlarmedFalse();
        Thread.sleep(70 * 1000);
        assertTrue(mMockAlarmReceiver.alarmed);
        mAlarmManager.cancel(mSender);
    }

    public void testSetTimeZone() throws Exception {

        Slog.d(TAG, "Android  mBuildVersion = " + mBuildVersion);
        Slog.d(TAG, "Android  mBuildSDK = " + mBuildSDK);
        Slog.d(TAG, "Android  RELEASE = " + android.os.Build.VERSION.RELEASE);

        CURRENT_TIME_ZONE = getCurrentTimeZone();
        BASE_TIME_ZONE = CURRENT_TIME_ZONE;
        Slog.d(TAG, "1st  BASE_TIME_ZONE = " + BASE_TIME_ZONE);

        CHANGE_TIME_ZONE = getChangedTimeZone();
        mAlarmManager.setTimeZone(CHANGE_TIME_ZONE);
        Thread.sleep(TIME_DELAY);

        CURRENT_TIME_ZONE = getCurrentTimeZone();
        Slog.d(TAG, "2nd  CHANGE_TIME_ZONE = " + CHANGE_TIME_ZONE);
        assertFalse(CURRENT_TIME_ZONE.equals(BASE_TIME_ZONE));

        mAlarmManager.setTimeZone(BASE_TIME_ZONE);
        Thread.sleep(TIME_DELAY);

        CURRENT_TIME_ZONE = getCurrentTimeZone();
        Slog.d(TAG, "3rd  FINAL_TIME_ZONE = " + CURRENT_TIME_ZONE);
        assertTrue(CURRENT_TIME_ZONE.equals(BASE_TIME_ZONE));
    }

    public void testSetTime() throws Exception {

        // currently there is no way to write Android system clock. When try to
        // write the system time, there will be log as
        // " Unable to open alarm driver: Permission denied". But still fail
        // after tried many permission.
        long src_time = 0 ;
        long tar_time = 0 ;
        tar_time = System.currentTimeMillis() + ONE_MINITE;

        mAlarmManager.setTime(tar_time);
        src_time = System.currentTimeMillis();
        Slog.d(TAG, "testSetTime  tar_time = " + tar_time / 1000);
        Slog.d(TAG, "testSetTime  src_time = " + src_time / 1000);
        assertTrue((src_time / 1000) == (tar_time / 1000));

        Thread.sleep(TIME_DELAY);
        mAlarmManager.setTime(System.currentTimeMillis() - ONE_MINITE + TIME_DELAY);
    }

    public void testErrorHandleAndDM() throws Exception {

       mAlarmManager.set(7, 0, mSender);
       try {
            Runtime.getRuntime().exec("dumpsys alarm");
        } catch (IOException e) {
            Slog.e(TAG, "dumpsys " + e);
        }
       try {
            Runtime.getRuntime().exec("am broadcast -a com.mediatek.dm.LAWMO_UNLOCK");
       } catch (IOException e) {
            Slog.e(TAG, "am broadcast " + e);
       }
    }

    private String getCurrentTimeZone() {
        tz = TimeZone.getDefault();

        if (mBuildVersion.equals(mAndroid_N)) {
            Slog.d(TAG, "getCurrentTimeZone  tz_ID= " + tz.getID());;
            return  tz.getID();
        } else {
            rawoffset = tz.getRawOffset() / 1000 / 3600;
            Slog.d(TAG, "getCurrentTimeZone  rawoffset = " + rawoffset);
            return rawoffsetToGMT(rawoffset);
        }
    }

    private String getChangedTimeZone() {
        String CurrentID = null;
        tz = TimeZone.getDefault();
        if (mBuildVersion.equals(mAndroid_N)) {
            CurrentID = tz.getID();
            Slog.d(TAG, "getChangedTimeZone  before CurrentID = " + CurrentID);
            if (CurrentID.equals(mTestTargertOne)) {
                tz.setID(mTestTargertTwo);
            } else if (CurrentID.equals(mTestTargertTwo)) {
                tz.setID(mTestTargertOne);
            }
            else {
                tz.setID(mTestTargertOne);
            }
            Slog.d(TAG, "getChangedTimeZone  after tz_ID= " + tz.getID());
            return  tz.getID();
        } else {
            if (rawoffset == 13)     //min: -11,  max: + 13
                rawoffset = rawoffset - 1;
            else
                rawoffset = rawoffset + 1;
            Slog.d(TAG, "getChangedTimeZone rawoffset = " + rawoffset);
            return rawoffsetToGMT(rawoffset);
        }
    }

   private String rawoffsetToGMT(int offset) {
        String GMTString = null;
        Slog.d(TAG, "rawoffsetToGMT offset = " + offset);
        if (offset >= 10)
            GMTString = "GMT+" + offset + ":00";
        else if (offset < 10 && offset >= 0)
            GMTString = "GMT+0" + offset + ":00";
        else if (offset > -10)
            GMTString = "GMT-0" + (-offset) + ":00";
        else if (offset <= -10)
            GMTString = "GMT-" + (-offset) + ":00";
        return GMTString;
    }
}
