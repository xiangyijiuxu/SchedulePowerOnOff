#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <pthread.h>
#include <error.h>

#include <cutils/properties.h>
#include <cutils/sockets.h>
#include <android/log.h>
#include "subsidylock_ipc.h"

#define LOGD(format, ...)  \
    __android_log_print(ANDROID_LOG_DEBUG, "SUBSIDYLOCK_IPC", (format), ##__VA_ARGS__ )

#define LOGW(format, ...)  \
    __android_log_print(ANDROID_LOG_WARN, "SUBSIDYLOCK_IPC", (format), ##__VA_ARGS__ )

#define LOGE(format, ...)  \
    __android_log_print(ANDROID_LOG_ERROR, "SUBSIDYLOCK_IPC", (format), ##__VA_ARGS__ )

#define LOGI(format, ...)  \
    __android_log_print(ANDROID_LOG_INFO, "SUBSIDYLOCK_IPC", (format), ##__VA_ARGS__ )

#define RILD_SOCKET_NAME "rild-oem"


static pthread_mutex_t s_mutex_get_status = PTHREAD_MUTEX_INITIALIZER;
//static pthread_mutex_t s_mutex_update_setting = PTHREAD_MUTEX_INITIALIZER;

int s_fd_get_status = 0;
//int s_fd_update_setting = 0;

static int s_subsidylock_status = 1;

int toByte(char c){
    if (c >= '0' && c <= '9') return (c - '0');
    if (c >= 'A' && c <= 'F') return (c - 'A' + 10);
    if (c >= 'a' && c <= 'f') return (c - 'a' + 10);

    LOGE("toByte Error: %c",c);
    return 0;
}

int checkByte(unsigned char* hexString){
    unsigned int i = 0;

    for (i = 0; i < strlen((const char*)hexString); i++) {
        if (!((hexString[i] >= '0' && hexString[i] <= '9')
            ||(hexString[i] >= 'A' && hexString[i] <= 'F')
            ||(hexString[i] >= 'a' && hexString[i] <= 'f'))) {

            LOGE("checkByte Error: %c", hexString[i] );
            return -1;
        }
    }

    return 0;
}


int parse_response(char* result, unsigned char* dest, unsigned int destLength) {
    int ret = ((result == NULL) ? MODEM_STATUS_OTHER_ERROR : (int)strlen(result));
    char *error_string = NULL;
    int error_code = 0;
    bool lock_state = false;

    if (NULL == result) {
        ret = MODEM_STATUS_OTHER_ERROR;
    } else if (NULL != result && 0 == strcmp(result, "(null)")) {
        ret = MODEM_STATUS_OK;
    } else {
        error_string = strtok(result, ":");
        /* if(NULL != error_string && 0 == strcmp(error_string, "+ESLBLOB")) {
            error_string = strtok(NULL, ":");
            int error_code = atoi(error_string);
            sprintf(dest, "%s", error_string);
            ret = MODEM_STATUS_OK;
            goto done;
        }*/
        //Parse ERROR:X (prefix is ERROR and X represent the error code)
        if(NULL != error_string && 0 == strcmp(error_string, "ERROR")) {
            error_string = strtok(NULL, ":");

            //Parse error code
            int error_code = atoi(error_string);
            switch(error_code) {
                case 8000:
                    ret = MODEM_STATUS_OK;//MODEM_STATUS_VERIFICATION_FAILED; //todo: check this.
                    break;

                case 8001:
                    ret = MODEM_STATUS_INVALID_ALGO_SIGNATURE;
                    break;

                case 8002:
                    ret = MODEM_STATUS_INVALID_CONFIG_DATA;//MODEM_STATUS_REBOOT_REQUEST;
                    break;

                case 8003:
                    ret = MODEM_STATUS_IMEI_MISMATCH;//MODEM_STATUS_REBOOT_REQUEST;
                    break;

                case 8004:
                    ret = MODEM_STATUS_LENGTH_MISMATCH;//MODEM_STATUS_REBOOT_REQUEST;
                    break;

                case 8005:
                    ret = MODEM_STATUS_OTHER_ERROR;//MODEM_STATUS_REBOOT_REQUEST; //todo: check this.
                    break;

                default:
                    ret = MODEM_STATUS_OTHER_ERROR; //todo: check this.
            }
        } else {
            LOGD("parse_response: %s", result);
            if(strcmp(result, "0") == 0) {
                LOGI("SUBSIDYLOCK STATUS: PERMANENT_UNLOCKED");
                dest[0] = 0;//false;
                if (s_subsidylock_status != 0) {
                    s_subsidylock_status = 0;
                    property_set("subsidylock.lockstatus_ril", "0");
                }
            } else {
                LOGI("SUBSIDYLOCK STATUS: LOCKED");
                dest[0] = 1;//true;
                if (s_subsidylock_status != 1) {
                    s_subsidylock_status = 1;
                    property_set("subsidylock.lockstatus_ril", "1");
                }
            }
        }
    }

done:
    LOGI("[parse_response]: %d", ret);
    return ret;
}

int connect_socket() {
    int fd = socket_local_client(RILD_SOCKET_NAME,
                  ANDROID_SOCKET_NAMESPACE_RESERVED, SOCK_STREAM);

    if(fd < 0) {
        LOGE("Fail to connect to socket rild-oem. return code: %d", fd);
        //return MODEM_STATUS_OTHER_ERROR;
    }

    // Set a timeout so that if nothing is read in 10 seconds, we'll stop
    // reading and quit.
    struct timeval tv;
    tv.tv_sec = SOCKET_RECV_TIME;
    tv.tv_usec = 0;

    if (setsockopt(fd, SOL_SOCKET, SO_SNDTIMEO, &tv, sizeof(tv)) == -1) {
        LOGE("Fail to set SOCKET SEND TIMEOUT for fd: %d, error: %s", fd,  strerror(errno));
    } else {
        LOGE("Sucess SOCKET SEND TIMEOUT for fd: %d", fd);
    }

    if (setsockopt(fd, SOL_SOCKET, SO_RCVTIMEO, &tv, sizeof(tv)) == -1) {
        LOGE("Fail to set SOCKET RECV TIMEOUT for fd: %d, error: %s", fd,  strerror(errno));
    } else {
        LOGE("Sucess SOCKET RECV TIMEOUT for fd: %d", fd);
    }

    return fd;
}

int send_data(int fd, int arg_count, uint32_t data_length, const void *data) {

    int ret = MODEM_STATUS_OK;
    int resp = 0;
    //Use "rild-oem" communication protocol, you must send data as following rules:
    //First, send the argument count
    //Second, the data length of following data
    //Third, the data by char* format
    //That is, arg. counts(=n)->length of arg[0]->arg[0]->length of arg[1]->arg[1]

    //(send-1)send argCount
    LOGI("(send-1). arg count: %d", arg_count);
    if(resp = send(fd, (const void*)&arg_count, sizeof(int), 0) != sizeof(int)) {
        if (resp == -1) {
            if(errno == EAGAIN) {
                errno = ETIMEDOUT;
                LOGE("send timeout");
            }
        } else {
            LOGE("Fail to send arg_count correctly");
        }
        ret = MODEM_STATUS_OTHER_ERROR;
        goto done;
    }

    //(send-2)send data length
    LOGI("(send-2). data length: %d", data_length);
    if(send(fd, (const void*)&data_length, sizeof(int), 0) != sizeof(int)) {
        LOGE("Fail to send data_length correctly");
        ret = MODEM_STATUS_OTHER_ERROR;
        goto done;
    }

    //(send-3)send SIM Lock Blob data
    //The operation format is "COMMAND,SIM_ID,[DATA]"
    //COMMAND:
    //        SIMMELOCK_SET      indicates to set sim status
    //        SIMMELOCK_GETKEY   indicates to get key
    //SIM:
    //        0                  sim slot 1
    //        1                  sim slot 2
    //DATA:
    //        SIM Lock Blob      in case of the COMMAND is SIMMELOCK_SET
    //                           DATA is SIM Lock Blob in hexadecimal format.
    //                           "3A01FB69520B92104C6A" is a 10 byte data 3A01FB69520B92104C6A.

    //sprintf(strData, "SIMMELOCK_SET,1,%s", data);
    //sprintf(data, "SIMMELOCK_SET,1,3A01FB69520B92104C6A");
    LOGI("(send-3). data: %s", (char *)data);
    if(send(fd, (const void*)data, data_length, 0) != (int)data_length) {
        LOGE("Fail to send data correctly");
        ret = MODEM_STATUS_OTHER_ERROR;
        goto done;
    }

done:
    LOGI("[send_data] Ret:%d.", ret);
    return ret;
}

int recv_data(int fd, uint32_t data_length, void *data) {
    int ret = MODEM_STATUS_OK;
    int recv_length = 0;
    int resp = 0;
    unsigned char* outBuffer = NULL;

    if (data == NULL) {
        LOGI("[recv_data] data is null or data length is wrong.");
        return MODEM_STATUS_OTHER_ERROR;
    }

    //Use "rild-oem" communication protocol, you must receive data as following rules:
    //First, the response data length of following response
    //Second, the reponse data by char* format

    //(recv-1)receive response data length
    if (resp = recv(fd, &recv_length, sizeof(recv_length), 0) != sizeof(recv_length)) {
        if (resp == -1) {
            if(errno == EAGAIN) {
                errno = ETIMEDOUT;
                LOGE("recv timeout");
            }
        } else {
            LOGI("recv fails in recv_length");
        }

        ret = MODEM_STATUS_OTHER_ERROR;
        goto done;
    }

    LOGI("(recv-1). recv length: %d, data length: %d, fd: %d", recv_length, data_length, fd);

    outBuffer = malloc((sizeof(char) * recv_length) + 1);
    memset(outBuffer, 0, (sizeof(char) * recv_length) + 1);
    //The response format is "RESULT,[DATA]"
    //RESULT:
    //        0                Success
    //        TBD              Error code
    //DATA:
    //       Shared Key        the response data when the previous COMMAND is SIMMELOCK_GETKEY
    //                         Modem shared key in hexadecimal format.
    //                         §3A01FB69520B92104C6A¡¨ is 10 byte data 3A01FB69520B92104C6A.

    //(recv-2)receive response data
    if (recv(fd, (void *)outBuffer, recv_length, 0) != recv_length) {
        LOGI("recv fails in outBuffer.");
        ret = MODEM_STATUS_OTHER_ERROR;
        goto done;
    }

    LOGI("(recv-2). outBuffer: %s, fd: %d", (unsigned char *)outBuffer, fd);

    recv_length = 0;

    /*if (checkByte(outBuffer) >= 0 && strlen((const char*)outBuffer) > 0) {
        recv_length = hexStringToByteArray(outBuffer, data, data_length);

        //outBuffer = (unsigned char*)data;
        //LOGI("(recv-3). data: %02X%02X%02X...", outBuffer[0], outBuffer[1], outBuffer[2]);

        if (recv_length < 0) {
            LOGI("recv_length is less than 0");
            ret = MODEM_STATUS_OTHER_ERROR;
            goto done;
        }
    } else {*/
        ret = parse_response((char *)outBuffer, data , data_length);
        if (ret < 0) {
            goto done;
        }
    //}

done:
    if (outBuffer != NULL) {
        free(outBuffer);
    }

    LOGI("[recv_data] Ret:%d, fd: %d", ((ret == 0) ? recv_length : ret), fd);
    return ((ret == 0) ? recv_length : ret);
}

int disconnect_socket(int fd) {
    if(fd < 0) {
        LOGE("[disconnect_socket] Invalid fd: %d", fd);
        //return MODEM_STATUS_OTHER_ERROR;
    }
    LOGE("[disconnect_socket] %d", fd);

    return close(fd);
}

uint8_t subsidylock_update_simlock_settings(uint8_t sim_id, const uint8_t *simlock_blob,
                                        uint32_t simlock_blob_length) {
    int ret = MODEM_STATUS_OK;
    char *result = NULL;
    unsigned int i = 0;
    //int fd = 0;
    int lock_ret = 1;

    unsigned int command_len = strlen("SUBSIDYLOCK_SET") +
                (COMMAND_SEPERATOR_LENGTH * 2) + COMMAND_SIM_ID_LENGTH ;
    char *command = NULL;

    unsigned int slb_len = (simlock_blob_length * 2) + 1;
    char *slb = (char *)calloc(slb_len, sizeof(char));

    if (simlock_blob == NULL) {
        LOGE("Received Null blob.");
        ret = MODEM_STATUS_OTHER_ERROR;
        goto done;
    }

    LOGD("subsidylock_update_simlock_settings: %s, %d", simlock_blob, simlock_blob_length);

    //memset(slb, 0, sizeof(char) * slb_len);

    for (i = 0; i < simlock_blob_length; i++) {
        sprintf((slb + (i*2)), "%02X", simlock_blob[i]);
    }

    LOGD("subsidylock_update_simlock_settings: slb(char array) %s", slb);
    do {
        lock_ret = pthread_mutex_trylock(&s_mutex_get_status);
        LOGD("try lock returns %d", lock_ret);
        if (lock_ret) {
            LOGE("s_mutex_update_setting lock unsuccessful");
        } else {
            LOGD("s_mutex_update_setting lock Successful");
            break;
        }
    } while (lock_ret);

    if (s_fd_get_status == 0) {
        s_fd_get_status = connect_socket();
    }

    LOGD("In set blob, s_fd_get_status = %d", s_fd_get_status);

    if (s_fd_get_status < 0) {
        ret = MODEM_STATUS_OTHER_ERROR;
        goto done;
    }

    command_len = command_len + strlen((const char*)slb) + 1;
    command = (char *)calloc(command_len, sizeof(char));

    sprintf(command, "SUBSIDYLOCK_SET,%d,%s", sim_id, slb);

    ret = send_data(s_fd_get_status, 1, command_len, command);
    if (ret != MODEM_STATUS_OK) {
        goto done;
    }

    result = (char *)calloc(COMMAND_RESULT_CODE_LENGTH, sizeof(char));

    ret = recv_data(s_fd_get_status, COMMAND_RESULT_CODE_LENGTH, result);
    if (ret != MODEM_STATUS_OK) {
        goto done;
    }

done:
    if (slb != NULL) {
        free(slb);
    }
    if (command != NULL) {
        free(command);
    }
    if (result != NULL) {
        free(result);
    }

    disconnect_socket(s_fd_get_status);
    s_fd_get_status = 0;
    lock_ret = pthread_mutex_unlock(&s_mutex_get_status);
    LOGD("s_mutex_update_setting unlock Successful: %d", lock_ret);
    return ret;
}

uint8_t subsidylock_get_modem_status(uint8_t sim_id, uint8_t *status_buffer,
                                uint32_t status_buffer_length) {
    int ret = MODEM_STATUS_OK;
    int lock_ret = 1;

    int command_len = strlen("SUBSIDYLOCK_GET_STATUS") +
                    COMMAND_SEPERATOR_LENGTH + COMMAND_SIM_ID_LENGTH ;
    char *command = NULL;

    if (status_buffer == NULL) {
        ret = MODEM_STATUS_OTHER_ERROR;
        goto done;
    }

    LOGD("subsidylock_get_modem_status: %d, %s, %d", sim_id, status_buffer, status_buffer_length);

    do {
        lock_ret = pthread_mutex_trylock(&s_mutex_get_status);
        LOGD("try lock returns %d", lock_ret);
        if (lock_ret) {
            LOGE("s_mutex_get_status lock unsuccessful");
            return MODEM_STATUS_OTHER_ERROR;
        } else {
            LOGD("s_mutex_get_status lock Successful");
            break;
        }
    } while (lock_ret);

    if (s_fd_get_status == 0) {
        s_fd_get_status = connect_socket();
    }

    LOGD("s_fd_get_status = %d", s_fd_get_status);

    if (s_fd_get_status < 0) {
        ret = MODEM_STATUS_OTHER_ERROR;
        goto done;
    }

    command_len = command_len + 1;
    command = (char *)calloc(command_len, sizeof(char));

    sprintf(command, "SUBSIDYLOCK_GET_STATUS,%d", sim_id);

    ret = send_data(s_fd_get_status, 1, command_len, command);
    if (ret != MODEM_STATUS_OK) {
        goto done;
    }

    ret = recv_data(s_fd_get_status, status_buffer_length, status_buffer);

    if (ret != MODEM_STATUS_OK) {
        goto done;
    }

    //LOGI("subsidylock_get_modem_status: [status_buffer] %s", status_buffer[0]);

done:
    if (command != NULL) {
        free(command);
    }

    disconnect_socket(s_fd_get_status);
    s_fd_get_status = 0;
    lock_ret = pthread_mutex_unlock(&s_mutex_get_status);
    LOGD("s_mutex_get_status unlock Successful: %d", lock_ret);
    return ret;
}

uint8_t Modem_Remote_Simlock(uint8_t *buffer_ptr, uint32_t buffer_len) {
    int ret = MODEM_STATUS_OK;
    ret = subsidylock_update_simlock_settings(0, buffer_ptr, buffer_len);
    if (ret == MODEM_STATUS_OK) {
        if (s_subsidylock_status == PERMANENT_UNLOCKED) {
            s_subsidylock_status = SUBSIDYLOCKED;
            property_set("subsidylock.lockstatus_ril", "1");
        } else {
            s_subsidylock_status = PERMANENT_UNLOCKED;
            property_set("subsidylock.lockstatus_ril", "0");
        }
        LOGD("update blob: s_subsidylock_status = %d", s_subsidylock_status);
    }
    return ret;
}

uint8_t Modem_Remote_Simlock_Get_Status(uint8_t * buffer_ptr,
                                        uint8_t buffer_len) {
    int ret = MODEM_STATUS_OK;
    ret = subsidylock_get_modem_status(0, buffer_ptr, buffer_len);
    if (ret != MODEM_STATUS_OK) {
        ret = MODEM_STATUS_INVALID_ALGO_SIGNATURE; // 1 = error.
    }
    return ret;
}



